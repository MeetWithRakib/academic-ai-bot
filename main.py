# ржкрзНрж░рзЯрзЛржЬржирзАрзЯ рж▓рж╛ржЗржмрзНрж░рзЗрж░рж┐ ржЗржорзНржкрзЛрж░рзНржЯ ржХрж░рж╛
import os
import logging
import re
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, constants
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
    ConversationHandler,
    CallbackQueryHandler,
)
import google.generativeai as genai
from flask import Flask
from threading import Thread

# Secrets ржерзЗржХрзЗ ржЯрзЛржХрзЗржи ржУ ржХрзА рж▓рзЛржб ржХрж░рж╛
TELEGRAM_TOKEN = os.environ.get('TELEGRAM_TOKEN')
GEMINI_API_KEY = os.environ.get('GEMINI_API_KEY')

# --- рзирзк/рзн ржмржЯржХрзЗ ржЬрж╛ржЧрж┐рзЯрзЗ рж░рж╛ржЦрж╛рж░ ржЬржирзНржп ржУрзЯрзЗржм рж╕рж╛рж░рзНржнрж╛рж░ ---
app = Flask('')

@app.route('/')
def home():
    return "Rakibuzzaman's Academic AI Bot is alive!"

def run():
    app.run(host='0.0.0.0', port=8080)

def keep_alive():
    t = Thread(target=run)
    t.start()
# ----------------------------------------------

# рж▓ржЧрж┐ржВ рж╕рзЗржЯржЖржк (рж╕ржорж╕рзНржпрж╛ ржирж┐рж░рзНржгрзЯрзЗрж░ ржЬржирзНржп)
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# Gemini AI ржХржиржлрж┐ржЧрж╛рж░ ржХрж░рж╛
genai.configure(api_key=GEMINI_API_KEY)
model = genai.GenerativeModel('gemini-1.5-flash-latest')

# Conversation states
SELECTING_SUBJECT, ASKING_QUESTION = range(2)

# ржмржЗ ржмрж╛ ржмрж┐рж╖рзЯрзЗрж░ рждрж╛рж▓рж┐ржХрж╛
SUBJECTS = {
    "political_theory": "рж░рж╛ржЬржирзИрждрж┐ржХ рждрждрзНрждрзНржм: ржкрж░рж┐ржмрж░рзНрждржи ржУ ржзрж╛рж░рж╛ржмрж╛рж╣рж┐ржХрждрж╛",
    "local_gov": "ржмрж╛ржВрж▓рж╛ржжрзЗрж╢рзЗрж░ рж╕рзНржерж╛ржирзАрзЯ рж╕рж░ржХрж╛рж░ ржУ ржкрж▓рзНрж▓рж┐ ржЙржирзНржирзЯржи",
    "public_policy": "ржЬржиржирзАрждрж┐ ржкрж░рж┐ржЪрж┐рждрж┐",
    "east_asia": "ржкрзВрж░рзНржм ржПрж╢рж┐рзЯрж╛рж░ рж╕рж░ржХрж╛рж░ ржУ рж░рж╛ржЬржирзАрждрж┐ (ржЪрзАржи, ржЬрж╛ржкрж╛ржи ржУ ржж. ржХрзЛрж░рж┐рзЯрж╛)",
    "env_dev": "ржкрж░рж┐ржмрзЗрж╢ ржУ ржЙржирзНржирзЯржи",
    "foreign_relations": "ржмрж╛ржВрж▓рж╛ржжрзЗрж╢рзЗрж░ ржмрзИржжрзЗрж╢рж┐ржХ рж╕ржорзНржкрж░рзНржХ",
    "law_making": "ржмрж╛ржВрж▓рж╛ржжрзЗрж╢рзЗрж░ ржЖржЗржи ржкрзНрж░ржгрзЯржи ржкрзНрж░ржХрзНрж░рж┐рзЯрж╛",
    "globalization": "ржмрж┐рж╢рзНржмрж╛рзЯржи, ржЖржЮрзНржЪрж▓рж┐ржХрждрж╛ржмрж╛ржж ржУ ржЖржирзНрждрж░рзНржЬрж╛рждрж┐ржХ ржЖрж░рзНржерж┐ржХ ржкрзНрж░рждрж┐рж╖рзНржарж╛ржи",
    "modern_thought": "ржЖржзрзБржирж┐ржХ рж░рж╛рж╖рзНржЯрзНрж░ржЪрж┐ржирзНрждрж╛"
}

# --- ржмржЯрзЗрж░ ржлрж╛ржВрж╢ржиржЧрзБрж▓рзЛ ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """/start ржХржорж╛ржирзНржб ржжрж┐рж▓рзЗ ржХржерзЛржкржХржержи рж╢рзБрж░рзБ ржХрж░рзЗ ржПржмржВ ржмрж┐рж╖рзЯ ржирж┐рж░рзНржмрж╛ржЪржирзЗрж░ ржмрж╛ржЯржи ржжрзЗржЦрж╛рзЯред"""
    logger.info("User %s started the conversation.", update.message.from_user.first_name)
    keyboard = [
        [InlineKeyboardButton(subject, callback_data=key)]
        for key, subject in SUBJECTS.items()
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        "ЁЯОУ рж╕рзНржмрж╛ржЧрждржо! ржЖржорж┐ рж░рж╛рж╖рзНржЯрзНрж░ржмрж┐ржЬрзНржЮрж╛ржи ржмрж┐ржнрж╛ржЧрзЗрж░ ржПржХржЬржи ржПржХрж╛ржбрзЗржорж┐ржХ ржЕрзНржпрж╛рж╕рж┐рж╕рзНржЯрзНржпрж╛ржирзНржЯред\n\n"
        "ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржирж┐ржЪрзЗрж░ рждрж╛рж▓рж┐ржХрж╛ ржерзЗржХрзЗ ржПржХржЯрж┐ ржмрж┐рж╖рзЯ ржирж┐рж░рзНржмрж╛ржЪржи ржХрж░рзБржи:",
        reply_markup=reply_markup,
    )
    return SELECTING_SUBJECT

async def subject_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ ржирж┐рж░рзНржмрж╛ржЪрж┐ржд ржмрж┐рж╖рзЯ ржЧрзНрж░рж╣ржг ржХрж░рзЗ ржПржмржВ ржкрзНрж░рж╢рзНржи ржХрж░рждрзЗ ржмрж▓рзЗред"""
    query = update.callback_query
    await query.answer()

    subject_key = query.data
    logger.info(f"Callback query received with data: {subject_key}")

    subject_name = SUBJECTS.get(subject_key)
    if not subject_name:
        await query.edit_message_text(text="ржПржХржЯрж┐ рж╕ржорж╕рзНржпрж╛ рж╣рзЯрзЗржЫрзЗред /start ржжрж┐рзЯрзЗ ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржиред")
        return ConversationHandler.END

    context.user_data['selected_subject'] = subject_name

    await query.edit_message_text(
        text=f"ржЖржкржирж┐ *{subject_name}* ржмрж┐рж╖рзЯржЯрж┐ ржирж┐рж░рзНржмрж╛ржЪржи ржХрж░рзЗржЫрзЗржиред\n\n"
             f"ржПржЦржи ржПржЗ ржмрж┐рж╖рзЯрзЗ ржЖржкржирж╛рж░ ржкрзНрж░рж╢рзНржиржЯрж┐ рж▓рж┐ржЦрзБржи...",
        parse_mode=constants.ParseMode.MARKDOWN,
    )
    return ASKING_QUESTION

async def handle_question(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ ржкрзНрж░рж╢рзНржи ржирж┐рзЯрзЗ AI ржжрж┐рзЯрзЗ ржЙрждрзНрждрж░ рждрзИрж░рж┐ ржХрж░рзЗ ржкрж╛ржарж╛рзЯред"""
    user_question = update.message.text
    subject_name = context.user_data.get('selected_subject', 'рж╕рж╛ржзрж╛рж░ржг')

    thinking_message = await update.message.reply_text("ржЖржкржирж╛рж░ ржкрзНрж░рж╢рзНржирзЗрж░ ржЙрждрзНрждрж░ ржкрзНрж░рж╕рзНрждрзБржд ржХрж░ржЫрж┐... тЬНя╕П")

    # --- рж╕ржмржЪрзЗрзЯрзЗ ржЙржирзНржиржд ржПржмржВ ржХрж╛рж░рзНржпржХрж░ Prompt ---
    prompt = f"""
    You are an expert academic assistant named 'Academic AI Bot', created by Rakibuzzaman for final year Political Science students in Bangladesh.

    **Core Task:**
    Answer the user's question from the subject "{subject_name}". The question is: "{user_question}".
    Your answer must be like a perfect answer from a high-quality academic guide book.

    **Tone and Language Rules (Very Important):**
    1.  **Language Style:** Use simple, clear, and easily understandable formal Bengali (рж╕рж╣ржЬржмрзЛржзрзНржп ржкрзНрж░рж╛рждрж┐рж╖рзНржарж╛ржирж┐ржХ ржмрж╛ржВрж▓рж╛). Avoid overly complex, archaic, or difficult words (ржжрзБрж░рзНржмрзЛржзрзНржп рж╢ржмрзНржж ржкрж░рж┐рж╣рж╛рж░ ржХрж░рзБржи). The goal is for students to read and remember it easily.
    2.  **Tone:** Your tone should be that of a helpful and knowledgeable teacher who makes difficult topics easy.

    **Structure and Formatting Rules (Strictly Follow):**
    1.  **Overall Structure:** The answer must be structured with a 'ржнрзВржорж┐ржХрж╛' (Introduction), 'ржорзВрж▓ ржЖрж▓рзЛржЪржирж╛' (Main Body), and 'ржЙржкрж╕ржВрж╣рж╛рж░' (Conclusion). Use these exact Bengali words as headings.
    2.  **Headings:** Make the headings (*ржнрзВржорж┐ржХрж╛*, *ржорзВрж▓ ржЖрж▓рзЛржЪржирж╛*, *ржЙржкрж╕ржВрж╣рж╛рж░*) bold using a single asterisk (*text*).
    3.  **Main Body:**
        - Present information using numbered lists (1., 2., 3.) or bullet points (тАв).
        - Each point should have a clear, bold subheading (e.g., *рзз. ржмрж┐ржЪрж╛рж░ ржмрж┐ржнрж╛ржЧрзЗрж░ рж╕рзНржмрж╛ржзрзАржирждрж╛*).
        - After the subheading, explain the point in 2-3 simple sentences.
    4.  **Bold Formatting:** Use bold *only* for the main headings (*ржнрзВржорж┐ржХрж╛*, etc.) and the subheadings within the main body. Do not use bold randomly in the middle of sentences.
    5.  **No Double Asterisks:** Never use `**` for bolding. Only use single asterisks `*`.

    **Example of a good point in the Main Body:**
    *рзй. ржХрзНрж╖ржорждрж╛рж░ ржнрж╛рж░рж╕рж╛ржорзНржп рж░ржХрзНрж╖рж╛*
    рж░рж╛рж╖рзНржЯрзНрж░рзЗрж░ рждрж┐ржиржЯрж┐ ржмрж┐ржнрж╛ржЧрзЗрж░ ржоржзрзНржпрзЗ ржХрзНрж╖ржорждрж╛рж░ ржнрж╛рж░рж╕рж╛ржорзНржп рж░ржХрзНрж╖рж╛ ржХрж░рж╛ ржмрж┐ржЪрж╛рж░ ржмрж┐ржнрж╛ржЧрзЗрж░ ржЕржирзНржпрждржо ржкрзНрж░ржзрж╛ржи ржХрж╛ржЬред ржПрж░ ржорж╛ржзрзНржпржорзЗ ржХрзЛржирзЛ ржПржХржЯрж┐ ржмрж┐ржнрж╛ржЧ ржпрзЗржи ржЕржкрзНрж░рждрж┐рж╣ржд ржХрзНрж╖ржорждрж╛рж░ ржЕржзрж┐ржХрж╛рж░рзА ржирж╛ рж╣рждрзЗ ржкрж╛рж░рзЗ, рждрж╛ ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рж╛ рж╣рзЯред

    Now, generate the perfect, easy-to-understand, and well-formatted answer.
    """

    try:
        response = await model.generate_content_async(prompt)

        # AI ржЕржирзЗржХ рж╕ржорзЯ ржбрж╛ржмрж▓ рж╕рзНржЯрж╛рж░ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ, рждрж╛ржЗ ржПржЯрж┐ржХрзЗ рж╕рж┐ржЩрзНржЧрзЗрж▓ рж╕рзНржЯрж╛рж░рзЗ рж░рзВржкрж╛ржирзНрждрж░ ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ
        # ржПржЯрж┐ ржПржХржЯрж┐ рж╕рзЗржлржЯрж┐ ржЪрзЗржХред
        formatted_text = response.text.replace('**', '*')

        await context.bot.edit_message_text(
            text=formatted_text,
            chat_id=update.effective_chat.id,
            message_id=thinking_message.message_id,
            parse_mode=constants.ParseMode.MARKDOWN,
        )
    except Exception as e:
        logger.error(f"Error generating or sending content: {e}")
        await context.bot.edit_message_text(
            text="ржжрзБржГржЦрж┐ржд, ржПржХржЯрж┐ ржкрзНрж░ржпрзБржХрзНрждрж┐ржЧржд рж╕ржорж╕рзНржпрж╛ рж╣рзЯрзЗржЫрзЗред ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржХрж┐ржЫрзБржХрзНрж╖ржг ржкрж░ ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржиред",
            chat_id=update.effective_chat.id,
            message_id=thinking_message.message_id,
        )

    await update.message.reply_text("ржЖржкржирж╛рж░ ржЖрж░ ржХрзЛржирзЛ ржкрзНрж░рж╢рзНржи ржерж╛ржХрж▓рзЗ /start ржХржорж╛ржирзНржб ржжрж┐ржиред")
    context.user_data.clear()
    return ConversationHandler.END


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    help_text = (
        "*ржмржЯ ржмрзНржпржмрж╣рж╛рж░рзЗрж░ ржирж┐рзЯржорж╛ржмрж▓рзА:*\n\n"
        "рзз. `/start` ржХржорж╛ржирзНржб ржжрж┐ржиред\n"
        "рзи. рждрж╛рж▓рж┐ржХрж╛ ржерзЗржХрзЗ ржЖржкржирж╛рж░ ржмрж┐рж╖рзЯржЯрж┐ ржмрж╛ржЯржирзЗ ржХрзНрж▓рж┐ржХ ржХрж░рзЗ ржирж┐рж░рзНржмрж╛ржЪржи ржХрж░рзБржиред\n"
        "рзй. ржПрж░ржкрж░ ржЖржкржирж╛рж░ ржкрзНрж░рж╢рзНржиржЯрж┐ ржЯрж╛ржЗржк ржХрж░рзЗ ржкрж╛ржарж╛ржиред\n\n"
        "ржпрзЗржХрзЛржирзЛ рж╕ржорзЯ ржХрж╛рж░рзНржпржХрзНрж░ржо ржмрж╛рждрж┐рж▓ ржХрж░рждрзЗ /cancel ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржиред"
    )
    await update.message.reply_text(text=help_text, parse_mode=constants.ParseMode.MARKDOWN)

async def about_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    about_text = (
        "*Academic AI Bot*\n\n"
        "ржПржЗ ржмржЯржЯрж┐ рж░рж╛рж╖рзНржЯрзНрж░ржмрж┐ржЬрзНржЮрж╛ржи ржмрж┐ржнрж╛ржЧрзЗрж░ ржЕржирж╛рж░рзНрж╕ ржЪрждрзБрж░рзНрже ржмрж░рзНрж╖рзЗрж░ рж╢рж┐ржХрзНрж╖рж╛рж░рзНржерзАржжрзЗрж░ ржкрзЬрж╛рж╢рзЛржирж╛рзЯ рж╕рж╣рж╛рзЯрждрж╛ ржХрж░рж╛рж░ ржЬржирзНржп рждрзИрж░рж┐ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред\n\n"
        "*ржирж┐рж░рзНржорж╛рждрж╛:*\n"
        "ржорзЛржГ рж░рж╛ржХрж┐ржмрзБржЬрзНржЬрж╛ржорж╛ржи\n"
-        "ржпрзЛржЧрж╛ржпрзЛржЧ: @meetwithrakib"
+       "ржпрзЛржЧрж╛ржпрзЛржЧ: @meetwithrakib"
    )
    await update.message.reply_text(text=about_text, parse_mode=constants.ParseMode.MARKDOWN)


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """ржХржерзЛржкржХржержи ржмрж╛рждрж┐рж▓ ржХрж░рзЗред"""
    logger.info("User %s canceled the conversation.", update.message.from_user.first_name)
    await update.message.reply_text("ржХрж╛рж░рзНржпржХрзНрж░ржо ржмрж╛рждрж┐рж▓ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред ржЖржмрж╛рж░ рж╢рзБрж░рзБ ржХрж░рждрзЗ /start ржХржорж╛ржирзНржб ржжрж┐ржиред")
    context.user_data.clear()
    return ConversationHandler.END


def main() -> None:
    application = Application.builder().token(TELEGRAM_TOKEN).build()

    # --- Conversation Handler ржПрж░ рж╕ржмржЪрзЗрзЯрзЗ ржирж┐рж░рзНржнрж░ржпрзЛржЧрзНржп ржПржмржВ рж╕рж░рж▓ ржЧржаржи ---
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            SELECTING_SUBJECT: [
                CallbackQueryHandler(subject_selected) # ржХрзЛржирзЛ pattern ржЫрж╛рзЬрж╛ржЗ, рж╕ржм ржмрж╛ржЯржи ржХрзНрж▓рж┐ржХ ржЧрзНрж░рж╣ржг ржХрж░ржмрзЗ
            ],
            ASKING_QUESTION: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_question)
            ],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
        per_message=False # ржПржЯрж┐ state management ржХрзЗ ржЖрж░ржУ рж╕рзНржерж┐рждрж┐рж╢рзАрж▓ ржХрж░рзЗ
    )

    application.add_handler(conv_handler)
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("about", about_command))

    keep_alive()
    application.run_polling()

if __name__ == "__main__":
    main()